```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-config}
# Load centralized configuration
source("config.R")

# Load lme4 package specifically for this script (statistical modeling)
if (!require("lme4", quietly = TRUE)) {
  user_lib <- "~/R/library"
  install.packages("lme4", lib = user_lib, repos = "https://cran.rstudio.com/")
  library("lme4")
}
```

```{r }
# Load data using config variables
file_name <- paste(DATASET_DIR, "dataCC_distance.csv", sep = "")
dataCC<- read.csv(file_name,header=TRUE)
dataCC <- subset(dataCC, select = c("n_Acc","x","y","shoe","row_number","horiz_dist"))
file_name <- paste(DATASET_DIR, "all_cont.csv", sep = "")
allcont<- read.csv(file_name,header=TRUE)
```





```{r }
# Load imager package for contour processing
if (!require("imager", quietly = TRUE)) {
  user_lib <- "~/R/library"
  install.packages("imager", lib = user_lib, repos = "https://cran.rstudio.com/")
  library("imager")
}

# Check if contour image exists in shared_data, if not create synthetic standardization
image_path <- paste(ROOT_PATH, "shared_data/new_contour_135.png", sep = "")
if (file.exists(image_path)) {
  message("Loading contour image for standardization from: ", image_path)
  # Load contour image for shoe 135 standardization
  image <- t(as.matrix(load.image(image_path)))
  xcoor <- t(matrix(rep((-COL_SHOE/2+1:COL_SHOE)*REL_Y_CORD/REL_COL_SHOE,ROW_SHOE),COL_SHOE,ROW_SHOE))
  ycoor <- -matrix(rep((-ROW_SHOE/2+1:ROW_SHOE)*REL_Y_CORD/REL_COL_SHOE,COL_SHOE),ROW_SHOE,COL_SHOE)
  entire_contour<-data.frame(x = xcoor[image==1],y =ycoor[image==1])# the data
  distance_per_y = entire_contour %>%group_by(y) %>%summarise(min_x = abs(min(x)),max_x = max(x))
  
  dist_shape = c()
  for (i in 1:nrow(dataCC)) {
    y_val = dataCC$y[i]
    if (dataCC$x[i] <= 0){
      new_val <- distance_per_y[(distance_per_y$y >= y_val-0.01) & (distance_per_y$y <= y_val+0.01), c('y','min_x')]
      closest_row_index <- which.min(abs(new_val$y - y_val))
      closest_value <- new_val[closest_row_index, ]$min_x
    }else{
        new_val <- distance_per_y[(distance_per_y$y >= y_val-0.01) & (distance_per_y$y <= y_val+0.01), c('y','max_x')]
      closest_row_index <- which.min(abs(new_val$y - y_val))
      closest_value <- new_val[closest_row_index, ]$max_x
    }
    dist_shape <- append(dist_shape, closest_value)
  }
  dataCC$distance_shape <- dist_shape
  
} else {
  message("Warning: Contour image not found at: ", image_path)
  message("Creating synthetic standardization using available data...")
  
  # Create synthetic standardization based on data distribution
  # Use quantiles to estimate shoe shape boundaries
  y_unique <- sort(unique(dataCC$y))
  
  # Create synthetic distance_per_y based on data distribution
  distance_per_y <- data.frame(
    y = y_unique,
    min_x = abs(sapply(y_unique, function(y_val) {
      x_vals <- dataCC$x[abs(dataCC$y - y_val) <= 0.05 & dataCC$x <= 0]
      if(length(x_vals) > 0) abs(min(x_vals)) else 0.15
    })),
    max_x = sapply(y_unique, function(y_val) {
      x_vals <- dataCC$x[abs(dataCC$y - y_val) <= 0.05 & dataCC$x > 0]
      if(length(x_vals) > 0) max(x_vals) else 0.15
    })
  )
  
  dist_shape = c()
  for (i in 1:nrow(dataCC)) {
    y_val = dataCC$y[i]
    if (dataCC$x[i] <= 0){
      # Find closest y value in distance_per_y
      closest_y_idx <- which.min(abs(distance_per_y$y - y_val))
      closest_value <- distance_per_y$min_x[closest_y_idx]
    } else {
      closest_y_idx <- which.min(abs(distance_per_y$y - y_val))
      closest_value <- distance_per_y$max_x[closest_y_idx]
    }
    dist_shape <- append(dist_shape, closest_value)
  }
  dataCC$distance_shape <- dist_shape
}

# Calculate new_x with protection against division by zero
dataCC$new_x <- ifelse(
  (abs(dataCC$x) + dataCC$horiz_dist) == 0,
  dataCC$x,  # fallback to original x if denominator is zero
  (dataCC$x * dataCC$distance_shape) / (abs(dataCC$x) + dataCC$horiz_dist)
)
file_name <- paste(DATASET_DIR, "dataCC_distance.csv", sep = "")
write.csv(dataCC, file_name, row.names = FALSE)
```

```{r }
Random<-function(nknotsx=3,nknotsy=5,dat=dataCC,model_feat = MODEL_FEATURE, initial_values )
{
  
  common_formula <- as.formula("n_Acc ~ (1 | shoe)")
  
  
  knotsx <- as.numeric(quantile(dat$x,1:nknotsx/(1+nknotsx)))
  knots_new_x <- as.numeric(quantile(dat$new_x,1:nknotsx/(1+nknotsx)))
  knotsy <-as.numeric(quantile(dat$y,1:nknotsy/(1+nknotsy)))
  knots_distance <-as.numeric(quantile(dat$min_dist,1:2/(3)))
  shoe<-dat$shoe
  
  
  
  if(model_feat == 'NEW_X_NS_XY'){
            formula_text <- "n_Acc ~ ns(dat$new_x,knots=knots_new_x):ns(dat$y,knots=knotsy) + (1 | shoe) "}
  else { stop("Invalid model_feat value")}
  cat(formula_text)
  est_formula <- as.formula(formula_text)  
  initial_values <- c(parameter1 = 0)  # Adjust these values
  est<- glmer(est_formula, data = dat, family = binomial(link = "logit"), control =glmerControl(optimizer="nlminbwrap"))#,  start = initial_values)
  #est<- glmer(est_formula, data = dat, family = binomial(link = "logit"), control =glmerControl(optimizer="bobyqa"))nlminbwrap
  cat("file_saving")
  file_name <- paste(SAVED_MODELS_DIR, MODEL_FEATURE,"_RELATIVE.rds", sep = "")
  saveRDS(est, file = file_name)
  return(est)
}
get_initial_values <- function(){
  file_name <- paste(SAVED_MODELS_DIR, "NS_XY.rds", sep = "")
  naomi_model <- readRDS(file = file_name)
  fixed_effects <- fixef(naomi_model) # View the fixed effects coefficients print(fixed_effects) 
  vals <- as.list(fixed_effects)
  if (grepl("DUMMY", MODEL_FEATURE)){ 
  vals <- c(vals, list(dummy_0to1 = 0, dummy_1to2 = 0))}
  else if (grepl("BIN_CAT", MODEL_FEATURE)){
    vals <- c(vals, list(bin_cat = 0))
  }
  return(vals) 
}

rand<-Random(dat=dataCC,initial_values=get_initial_values())
```


```{r }

```


  
